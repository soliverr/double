# Дубль

## Программа, которой нет!

**Автор:** Кряжевских Сергей  
**Email:** soliverr@gmail.com  
**Дата:** 2016-04-07
**Издание:** 1.0  
**Лицензия:** Public Domain

### Аннотация

**Дубль**: Сохраняйте, структурируйте, воспроизводите, обменивайтесь собственными знаниями и личным опытом.

---

## Введение

Работая за компьютером, мы часто изобретаем свои уникальные способы взаимодействия с программной вычислительной средой, организуем наши данные понятным нам способом, автоматизируем собственные приёмы работы. С течением времени мы так или иначе накапливаем личный опыт действий в вычислительной среде. Мы устанавливаем и настраиваем для себя рабочую среду и необходимые нам программы, организуем хранение документов и медиафайлов, делаем или не делаем резервное копирование и выполняем множество других действий в *"вычислительной окружающей среде"*.

Вычислительные системы проникают во все сферы нашей жизнедеятельности. И мы используем разнообразные устройства, взаимодействуя друг с другом или какими-то общественными структурами, социальными или государственными службами. Всё больше информации преобразуется в электронную форму, доступную для обработки в *вычислительной окружающей среде*. Мы сами можем делать заметки и описывать удачные или неудачные попытки взаимодействий.

Параллельно с нашей *социальной* окружающей средой создана, функционирует и развивается *вычислительная* окружающая среда, которая всё теснее переплетается с реальной жизнью и воздействует на неё.

Когда мы хотим сохранить полезные знания для будущего, поделиться ими с другими или просто для того, что бы "не забыть", мы, естественно, пишем какой-либо текст. Мы можем написать заметку, статью или обстоятельное сообщение и разместить его в публичной Wiki, журнале или газете, в форуме, собственном блоге или социальной сети. Мы, конечно же, постараемся выразить свои знания таким образом, что бы они были как можно более понятны, что бы последующая их интерпретация (прочтение и применение) вызывала как можно меньше проблем. Тогда наша заметка или статья станет популярной у большего числа людей, мы, даже, сможем получить какую-то обратную связь, что-то вроде *"Круто! Я сделал, как написано, и получил то, что хотел!"*.

Глобальные поисковые системы заметно облегчают нам поиск необходимой информации: поисковые запросы ранжируются по популярности, результаты поиска ранжируются по релевантности, контексту, области применения. Наши повседневные запросы *"как сделать"* и потребности в информации обеспечиваются множеством сайтов, журналов, экспертных сообществ и форумов, дающих обоснованные и не очень советы и объяснения, приводящие аргументы за и против, дающие порядок действий и инструкции по выполнению определённых действий. На один поисковый запрос *"как сделать"* можно получить десятки, если не сотни, ссылок на различные тексты. Часть этих текстов необходимо прочитать, понять и попробовать воспроизвести инструкции и действия, описанные в них. Если попробовать записать данный способ достижения цели, то он может значительно или не очень отличаться от найденных инструкций. Получается, что в процессе интерпретации знаний генерируются дополнительные *новые* знания.

Как мы видим, процесс генерации знаний бесконечен. Конечно время их использования. Знания сохраняют свою актуальность при активном использовании. Спустя некоторое время мы забываем все детали и тонкости, меняются вычислительные системы, обновляются программы и становиться проще найти новую статью *"как сделать"*, чем вспомнить и разобраться в своих же заметках и описаниях действий.

Существует множество программ и публичных сервисов типа [PIM](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80), [VDA](https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%86%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%BE%D0%B9_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%BD%D0%B8%D0%BA), [PDA](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D0%BC%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BF%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80) и т.п., позволяющих организовать личную информацию, оказывающих помощь в социальных взаимодействиях (заказ билетов, бронирование гостиниц и пр.). Эти программы предназначены для личного использования или обеспечивают групповую работу или функции социальных сетей.

В среде системного администрирования вычислительных комплексов развиваются проекты управления программной конфигурацией вычислительных систем ([configuration management](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)). В среде сетей передачи данных - проекты программно-определяемых сетей ([SDN](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D0%BC%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C)).

Наверное, самый популярный способ организации собственных знаний на сегодняшний день - это использование Wiki-подобных программ, в виде публичных или локальных сервисов. Wiki - это отличный способ делать записи на различные темы и связывать эти записи между собой или с какими-то внешними источниками информации.

Проблема с Wiki, как и с другими способами организации знаний (блоги, форумы и т.д.) в том, что они представляют знания пассивно. Нужен человек, который бы начал интерпретировать эти знания, то есть, выполнять действия, которые описаны на какой-то странице в Wiki. Если такие инструкции относятся к действиям в вычислительной среде, то не так уж и необходим человек для их выполнения.

Но есть ли такие концепции и программные проекты, которые предназначены для воспроизведения ваших действий, вашего личного опыта взаимодействия с в вычислительной окружающей среде?

Кажется, что подобных программ и концепций нет. Именно поэтому и возникла идея проекта **Дубль**.

---

## Для чего нужен **Дубль**?

Основная идея проекта Дубль в том, чтобы помочь нам найти свой собственный способ организации и представления знаний. Для каждого, кто этим заинтересуется и захочет это делать.

В этом смысле нет необходимости создавать какую-то универсальную программу или эффективный способ представления для работы с самыми разнообразными знаниями. Нет необходимости создавать искусственно-разумную вычислительную систему, будь то экспертная система, система вывода на знаниях или что-то другое из области искусственного интеллекта.

Первоначальная цель гораздо скромнее - описать в одном месте (например, в одном файле) последовательность действий, приводящих к достижению какой-либо цели. Дополнить описание способом автоматического воспроизведения этих действий. По-возможности, ввести критерии оценки достижения поставленной цели с помощью описанных действий.

Возможно, либо уже существует какая-то программа, которая позволяет связывать определённые наборы действий (задач) с определёнными целями, и автоматически выполнять эти действия. Но кажется достаточно интересной попытка создания такой программной среды. Такой программы, которая бы не существовала отдельно, а появлялась в процессе обработки наших "знаний".

Вы формулируете цель; формируете задачи, выполняя которые, можно попытаться добиться этой цели; и формулируете правила создания программы, которая может выполнить эти задачи автоматически. То есть, программа **Дубль** как бы существует только на момент достижения определённой цели. Поставленная цель и формирует собственно программу.

Подобная идея создания программ с позиции описания требуемого функционала сформулирована [Дональдом Кнутом](https://en.wikipedia.org/wiki/Donald_Knuth) в програмной системе [CWEB](https://en.wikipedia.org/wiki/CWEB). В ней акцент делается на структурные блоки, описывающие требуемый функционал, а к этим структурным блокам добавляются фрагменты текста на языке программирования, реализующие описанные функции.

В поекте **Дубль** акцент смещён не на создание программы, а на воспроизводство определённых действий в вычислительной окружающей среде. Какие-то из описанных действий создают или модифицируют собственно саму программу. Но все эти действия рассматриваются как наши знания, выраженные именно таким способом, что бы обеспечить автоматическое достижение поставленной цели. Автоматическое - значит без нашего непосредственного участия! По-возможности...

---

## Данные и метаданные

Мы получаем данные, когда представляем объекты и идеи нашего мира в вычислительной среде. С этого момента мы мыслим в категориях данные - программа. То есть, мы сумели что-то представить в виде данных и создали программу для обработки этих данных.

Собственно, программа - это тоже данные. Это данные, которые представляют какой-либо алгоритм в вычислительной среде. Программу можно попытаться выполнять с помощью механических, паровых или электрических машин. Наиболее эффективными, на данное время, являются электронные машины, хотя уже появляются молекулярные, оптические и квантовые вычислительные системы. Возможно, кто-то в будущем сумеет построить гравитационную вычислительную систему.

Связь категорий программа - данные приводят к понятию [метаданных](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5). Программа - как метаданные. Хотя обычно говорят о метаданных и метапрограммах.

Если meta воспринимать буквально, как цель, конечный пункт; то можно заметить, что добавление каких-то (новых) данных в вычислительную систему практически всегда влечёт за собой создание программы, то есть алгоритмически выраженной цели обработки этих данных. Программа возникает не сама по себе, а как результат достижения определённой, часто, заранее заданной, цели.

Эта общность программ и данных в вычислительной среде является основой возможности объединения в виде единого представления знаний и алгоритмов их обработки.

Известно, что данные в вычислительных системах, представлены в виде какого-либо формата хранения, типа данных. Программный или аппаратный метод обработки и сам тип данных жёстко связаны и обусловлены рядом ограничений. С другой стороны, универсальность базовой модели вычислительных систем состоит в том, что на программном уровне можно реализовать обработку практически любого типа данных. Добавление к исходным данным в каком-либо жёстком формате новых данных влечёт появление метаданных и программы для их обработки.

Какие либо данные могут представлять способ изменения самой программы, в этом случае говорят о мета программировании, когда программа может изменять саму себя в момент исполнения. Появляются языки программирования, реализующие такую возможность.

Цель объединения в одной форме представления человеко-читаемых и машинных данных заставляет отказаться от удобства представления в бинарной форме и использовать более трудоёмкую в обработке текстовую форму представления данных. Тестовая форма представления данных и форматы представления этих данных открыли широкие возможности развития меж взаимодействия вычислительных систем и человечества. Искусственный разум, способный понять человека, уже не фантастика. Фантастика - уже в том, сможем ли мы понять искусственный разум, если он сумеет генерировать для себя заранее не заданные цели и находить способы их достижения.

---

## Semantic Web: XML, RDF, RDFa и другие

Таким образом, идеи [Semantic Web](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D0%B0) по синтезу "человеческих" и "машинных" знаний и способу их выражения находят широкий спектр приложений.

Основные идеи объединения человеческих и машинных знаний выражены в виде стандартов консорциума W3C и объединяются понятием Semantic Web. Здесь мы рассмотрим некоторые основные принципы, заложенные в основу представления знаний для вычислительных систем и человека. Собственно говоря, многозначность человеческого языка, контекст и смысл высказывания уточняются и более-менее однозначно маркируются с тем, чтобы предоставить возможность автоматической обработки информации с помощью вычислительных систем.

### XML - расширяемый язык разметки

XML - реализует идею представления информации в понятной форме как для человека, так и для компьютера. Он определяет базовую модель элемента данных: сущность и её атрибуты; и модель представления: вложенная древовидная структура когда сущности располагаются иерархически, но смысл этих иерархических связей не задаётся. Зачастую, вложенные сущности рассматриваются как атрибуты сущностей, расположенных выше по иерархии.

XML реализует самую простейшую модель представления данных, а также вводит типизацию данных в виде схемы XSD. Это позволило использовать этот формат достаточно широко, так как данные, представленные в этом формате могут быть интуитивно правильно интерпретированы человеком. Основная сложность - это правильная интерпретация подобного рода данных другой программой. Именно об этих проблемах пишет в своей статье "Why RDF model is different from the XML model" https://www.w3.org/DesignIssues/RDF-XML.html Тим Бернс-Ли. В ходе поиска решения данной проблемы появился формат описания RDF.

### RDF - формат описания метаданных (знаний)

RDF реализует модель представления данных в виде триплетов: субъект - отношение - объект. Таким образом, при машинной обработке каждый элемент данных однозначно определяется как одна из частей триплета, что устраняет неоднозначность описания с помощью XML. Эта отличная идея однако достаточно трудна в реализации, поскольку требует полной классификации всех элементов данных с позиций триплета.

### RDFa - встраиваемый формат описания метаданных (знаний)

RDFa возник как один из способов избежать громозкости описаний с помощью RDF. Идея заключается в том, что семантические маркеры встраиваются в данные по мере необходимости, не ко всем элементам, а только к необходимым, наиболее существенным. То есть, RDFa - это своего рода подсказки для однозначной интерпретации определённых элементов информации. Данная идея получила большее развитие в так называемых микро форматах.

### Микроформаты и микроданные

Эти форматы ещё более упрощают способ семантической разметки элементов информации. Дальнейшее упрощение семантической разметки реализовано в так называемых микроданных, объединённых и продвигаемых проектом [schema.org](http://schema.org).

### Разметка информации

Таким образом, идея разметки информации (в частности, текстов) позволяет закрепить определённый способ обработки соответствющих маркеров разметки. Это позволяет реализовать модель представления информации в вычислительных системах. Аналогичным образом действует и семантическая разметка: позволяет закрепить модель представления знаний и осуществить интерпретацию элементов информации с позиций человека или осмысленным с точки зрения человека способом.

Использование формата DocBook видимо будет достаточно удобным, так как этот формат в первую очередь предназначен для разметки текстовых документов, но также в версии 5.0 реализует поддержку RDFa [Common RDFa Lite Attributes](http://tdg.docbook.org/tdg/5.1/ref-elements.html). Кроме того, в DocBook существует возможность создания документа на нескольких языках, то есть можно сохранить оригинальный текст и его перевод для каждого структурного элемента текста в одном месте, в одном файле. Собственный [атрибут lang в DocBook](http://tdg.docbook.org/tdg/5.0/ch01.html#introduction-rng.7.5) заменяется стандартным для XML атрибутом [xml:lang](https://www.w3.org/TR/REC-xml/#sec-lang-tag).

---

## Модель проекта Дубль

Использование какого-либо формата данных влечёт за собой программную реализацию и внутреннее представление данных, используемое при обработке. Чем ближе друг к другу внешний формат представления данных и внутренняя форма представления, тем проще и понятнее становиться программы, алгоритмы обработки.

Обычно при проектировании вычислительной программной среды проектируют также внутреннюю модель представления данных и способы процедуры работы с ней. Такие процедуры составляют ядро программного проекта и обеспечивают доступ и модификацию данных во внутреннем программном представлении, и реализуются в виде библиотеки программного кода.

Представление данных и код для его обработки с течением времени всё больше влияют друг на друга и становиться достаточно сложно или не возможно реализовывать цели, не предусмотренные на этапе проектирование программной системы. Эта трудность приводит к идеям универсальных форматов данных, универсальных внутренних моделей представлений, универсальных программ и универсальных алгоритмов. В реальности, желаемая универсальность и неотемлемая вычислительная эффективность вступают в противоречие. Это позволяет с интересом продвигаться по пути развития эффективных универсальных программ.

Идея проекта Дубль заключается в том, что не требуется жёстко до этапа проектирования программы, проектировать внутреннюю модель преставления данных. Внутренняя модель, а точнее способ её реализации становться просто очередной целью в пути достижения главной цели. Значит, получение внутренней модели можно сформулировать в виде конкретных задач, решение которых позволит преодолеть эту цель.

Таким образом, описание внутренней модели - это наши знания, выраженные таким образом, чтобы их можно было автоматически интерпретировать и получить программу с необходимым функционалом. В этом смысле полезными оказываются идеи XML, где реализована достаточно примитивная модель данных, не накладывающая ограничений на её дальнейшее использование. А сами ограничения выражаются на языке этой же модели представления данных.

В качестве внутренней модели проекта Дубль можно выбрать, например, модель парных связей: цели-средства, цели-задачи, задачи-средства, средства-реализации в отношении один ко многим. То есть, существует или формулируется множество целей. Для каждой цели формулируется множество задач, решение которых должно привести к достижению цели. С каждой задачей связаны программные средства, осуществляющие её решение. Программные средства представлены в виде набора одной или нескольких аналогичных программ, библиотек языка программирования или операционной системы и пр. При этом не накладывается никаких ограничений на создание подобных связей. То есть, на определённом этапе конкретная программа может интерпретироваться как задача, а затем переместиться во вновь сформированный список средств или стать частью реализации.

Из предыдущего параграфа можно заметить, что для описания модели вводяться опеределённые категории, с которыми будет связана программаная реализация. При этом уже сейчас видно, что программная реализация достаточно сложная, подразумевающая несколько уровней интерпретации. Поэтому хорошо бы реализовать какую-то очень простую модель, из которой можно было бы получить все остальные модели. Эту модель в проекте Дубль назовём зерно.

---

## Создание программы Дубль

На этот момент становиться понятно, что совсем без программы не обойтись, так как мы не собираемся адаптировать свой собственный способ представления знаний, а собираемся объединить в одном месте знания и способ их обработки.

Для получения программы Дубль, в которой можно что-то делать моим собственным способом, необходимо разработать и этот способ. Наша первая цель, получить программу, которая сможет в дальнейшем модифицировать себя и обеспечивать выполнение будущих действий и достижение заранее не определённых целей.

В проекте Дубль возникла идея реализации зерна - определённым образом описанной реализации действий, которая будет модифицировать существующую реализацию. Средой для роста зерна каждый раз будет явяться сама программа Дубль.

Здесь описан алгоритм создания первой реализации программы Дубль, реализующей идею зерна.

### Об унивесальном способе выделения зерна

Зерно - текст оформленный по правилам языка разметки, DocBook. Не хочется использовать парсинг XML и средства построения моделей DocBook, не писать собственный код. Универсальным средством обработки текстовой информации можно считать регулярные выражения, реализации общедоступной библиотеки regexp есть практически во всех распространённых языках программирования. Значит можно сформулировать регулярное выражение (почти) не зависимое от языка программирования и считать его протозерном для "выращивания" первого экземпляра программы проекта Дубль. Так как программа Дубль в вычислительной окружающей среде должна быть реализована на каком-либо языке программирования, то применение протозерна будет происходить в конкретной языковой среде, а это позволяет получить различные реализации программы Дубль. Уже это открывает интересные возможности для оценки выжыиваемости проекта: смогут ли различные реализации проекта Дубль, полученные из одного протозерна в будущем найти способ межвзаимодействия, какие будущие зёрна покажут большую выживаемость и в какой вычислительной окружающей среде.

### Регулярное выражение для протозерна

Создаётся с учётом входных данных в виде XML, в формате DocBook. Могут быть любые другие форматы. Применяется человеком в соответствующей программно-языковой среде для получения работающей программы. Цель - программа, которая может воспроизвести сама себя, "читая" это же описание.

### Реализация Дубль в языковой среде Ruby

Использовать только встроенные (внутренне-присущие) средства языка. Использование возможностей именно данной языковой среды:

- Создание модуля Double - как пространства имён в языковой среде
- ОО-модель, класс Seed - класс работы с зерном
- Чтение - метод получения зерна из файла описания
- Запись - сохранение текстовой формы зерна в файл
- Загрузка - воспроизведение зерна в языковой среде
- Помощь - взаимодействие с человеком
- Получение исполняемой программы для последующих запусков

Испытание: получение программы уже исполняемой программой и сравнение результата: строковое сравнение нового зерна и текущего зерна. Сама программа рассматривается как текущее зерно.

Зерно - массив строк.

**Данный файл можно рассматривать как цель - получение первой программы Дубль.** Программа нужна, так как мы хотим автоматически выполнять действия в вычислительной окружающей среде. Это может делать программа.

То есть необходимо разработать зерно обеспечивающее минимальный функционал, как то - чтение файла DocBook и получение из него блока зерна (это встроенная цель или то что называется инициализация - всегда производимые действия), загрузка блока зерна, то есть модификация программы Дубль, и выполнение действия по умолчанию: спросить пользователя, или интерпретировать какой-то командный поток действий для заданной цели.

На данный момент нет никакой программы, поэтому первой целью является её получение в какой-то языковой среде.

Как универсальный способ использование регулярных выражений для поиска зерна.

Само регулярное выражение - это программа для среды интерпретации. Библиотеки интерпретации регулярных выражений существуют для практически всех языков программирования.

#### Подсекция: создание программы на языке Ruby

- О необходимости модуля
- Зерно - как класс SEED
- Метод чтения из файла всех блоков для языка Ruby
- Метод сохранения в файл
- Метод помощь
- Метод установки разрешений на исполнение
- Описание создания исполняемой программы проекта Дубль
  - IRB
  - Зерно
  - Сохранение в файл
  - Установить разрешения

Действие проверка наличия загруженного модуля Дубль:

```ruby
Module.constants.select{|c| ( true if c.to_s == "Double" ) }
```

Команда регулярного выражения и выгрузки в файл, загрузка файла и получение модуля Дубль в среде Ruby:

```ruby
seed = File.read('Double.xml').match(/<programlisting language="ruby">(.*)<\/programlisting>/m)[1].strip
```

Команда помощи: список возможных действий

Сохранение программы Дубль в файл

Нужны теги для цели и задачи

---

## Примеры кода Ruby

```ruby
File.read('Double.xml').match(/<programlisting language="ruby">(.*)&lt;\/programlisting>/m)[0].scan(/<programlisting language="ruby">(.*?)&lt;\/programlisting>/m){|w| print "#{w}\n" }
```

```ruby
File.read('Double.xml').gsub(/&lt;\!--.*?--&gt;/m,'').match(/<programlisting language="ruby">(.*)&lt;\/programlisting>/m)[0].scan(/<programlisting language="ruby">(.*?)&lt;\/programlisting>/m){|w| print "#{w}\n" }
```

---

## Заключение

В результате должна быть создана программа Дубль с базовым функционалом: показать цель и связанные с ней действия, выполнить действия для заданной цели. Показать граф решения: цели, подцели, выбранные действия.
